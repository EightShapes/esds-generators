import { flatten } from 'flat';
import chalk from 'chalk';
import fs from 'fs';
import path from 'path';
import jsBeautify from 'js-beautify';
import mkdirp from 'mkdirp';
import yaml from 'yamljs';
import Listr from 'listr';

function tokensToJson(sourceFile) {
  let tokens = {},
    parsedTokens;
  try {
    let rawYaml = fs.readFileSync(sourceFile, 'UTF-8');
    let interpolatedYaml = interpolateYamlVariables(rawYaml);
    parsedTokens = yaml.parse(interpolatedYaml);
    if (parsedTokens !== null && typeof parsedTokens === 'object') {
      tokens = parsedTokens;
    }
  } catch (e) {
    // eslint-disable-next-line no-console
    tokens = false;
    console.log(chalk.red(`${e.message}\n${e.parsedLine}`));
  }
  return tokens;
}

function traceTokenReferenceToValue(value, rawYaml) {
  const referenceRegex = /\*(.*)/gm;
  let m;
  m = referenceRegex.exec(value);
  if (m === null) {
    return value;
  } else {
    const match = m[1];
    const searchRegex = new RegExp(`&${match} (.*)`, 'gm');
    m = searchRegex.exec(rawYaml);
    if (m === null) {
      return `CANNOT FIND VALUE FOR ${match}`;
    } else {
      const nextMatch = m[1];
      return traceTokenReferenceToValue(nextMatch, rawYaml);
    }
  }
}

function interpolateYamlVariables(rawYaml) {
  const AnchorRegex = /&(\S*) (.*)/gm;
  let m;
  const anchorReplacements = {};

  while ((m = AnchorRegex.exec(rawYaml)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === AnchorRegex.lastIndex) {
      AnchorRegex.lastIndex++;
    }

    // The result can be accessed through the `m`-variable.
    const replacementKey = m[1];
    const replacementValue = m[2];
    anchorReplacements[replacementKey] = traceTokenReferenceToValue(
      replacementValue,
      rawYaml,
    );
  }

  const ReferenceRegex = /!\{\*\S*\}/;
  while ((m = ReferenceRegex.exec(rawYaml)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === ReferenceRegex.lastIndex) {
      ReferenceRegex.lastIndex++;
    }

    m.forEach(match => {
      const replacementKey = match.replace(/!|\{|\*|\}/g, '');
      let replacement = anchorReplacements[replacementKey];
      replacement = replacement.replace(/^"|"$/g, ''); // Remove double quotes from beginning and end of value
      rawYaml = rawYaml.replace(match, replacement);
    });
  }

  return rawYaml;
}

function writeTokensJsonFile(tokens, yamlFileName, options) {
  const jsonOutputFilename = path.parse(yamlFileName).name + '.json',
    jsonOutputFilepath = path.join(
      process.cwd(),
      options.dest,
      jsonOutputFilename,
    ),
    tokensSuffix = path.parse(yamlFileName).name;

  let jsonTokens = {};
  jsonTokens[
    `${options.tokenNamespace.replace(/-/g, '_')}_${tokensSuffix}`
  ] = tokens;

  // JSON tokens
  if (!fs.existsSync(options.dest)) {
    mkdirp.sync(options.dest);
  }

  fs.writeFileSync(jsonOutputFilepath, jsBeautify(JSON.stringify(jsonTokens)));
}

function getTokensScssMap(tokens, yamlFileName, options) {
  let tokensSuffix = path.parse(yamlFileName).name,
    sassMap = `$${options.tokenNamespace}-${tokensSuffix.replace(
      /_/g,
      '-',
    )}: (\n`,
    indentationLevel = 1,
    variablePrefix = `$${options.tokenNamespace}-`;

  sassMap += generateScssMapSection(tokens, indentationLevel, variablePrefix);
  sassMap += ');\n';
  return sassMap;
}

function getIndentationString(indentationLevel) {
  let indentation = '';
  for (var i = 0; i < indentationLevel; i++) {
    indentation += '    ';
  }

  return indentation;
}

function generateScssMapSection(node, indentationLevel, variablePrefix) {
  let output = '',
    indentation = getIndentationString(indentationLevel);
  for (var key in node) {
    let value = node[key],
      prefix = `${variablePrefix}${key}-`;

    if (typeof value === 'object') {
      value = generateScssMapSection(value, indentationLevel + 1, prefix);
      output += `${indentation}'${key}': (\n`;
      output += value;
      output += `${indentation}),\n`;
    } else {
      output += `${indentation}'${key}': ${variablePrefix}${key},\n`;
    }
  }

  output = output.replace(/,\n$/, '\n');

  return output;
}

function writeTokensScssFile(tokens, yamlFileName, options) {
  const scssOutputFilename = path.parse(yamlFileName).name + '.scss',
    scssOutputFilepath = path.join(
      process.cwd(),
      options.dest,
      scssOutputFilename,
    ),
    scssMap = getTokensScssMap(tokens, yamlFileName, options);
  let flattenedTokens = flatten(tokens, { delimiter: '-' }),
    scss = `// DO NOT EDIT: This file is automatically generated by a build task\n\n`,
    prevVarNameParent = false;

  // SCSS tokens
  for (var varName in flattenedTokens) {
    let value = flattenedTokens[varName],
      varNameParent = varName.substr(0, varName.indexOf('-'));
    if (prevVarNameParent && prevVarNameParent !== varNameParent) {
      scss += '\n';
    }
    prevVarNameParent = varNameParent;

    scss += `$${options.tokenNamespace}-${varName}: ${value} !default;\n`;
  }
  scss += scssMap + '\n';
  scss +=
    `@function ${options.tokenNamespace}-token($keys...) {\n` +
    `    $map: $${options.tokenNamespace}-tokens;\n` +
    '    @each $key in $keys {\n' +
    '        $map: map-get($map, $key);\n' +
    '    }\n' +
    '    @return $map;\n' +
    '}\n';

  if (!fs.existsSync(options.dest)) {
    mkdirp.sync(options.dest);
  }
  fs.writeFileSync(scssOutputFilepath, scss);
}

export async function compileTokens(options) {
  const sourceFile = options.sourceFile;
  let tokens;
  const tasks = new Listr([
    {
      title: 'Parse Tokens',
      task: () => {
        tokens = tokensToJson(sourceFile);
        if (!tokens) {
          throw new Error(chalk.red('Tokens file could not be parsed'));
        }
      },
    },
    {
      title: 'Create scss tokens',
      skip: () => !options.formats.includes('scss'),
      task: () => {
        tokens.namespace = '"' + options.tokenNamespace + '"';
        writeTokensScssFile(tokens, path.basename(sourceFile), options);
      },
    },
    {
      title: 'Create json tokens',
      skip: () => !options.formats.includes('json'),
      task: () => {
        tokens.namespace = options.tokenNamespace;
        writeTokensJsonFile(tokens, path.basename(sourceFile), options);
      },
    },
  ]);

  try {
    await tasks.run();
    console.log(chalk.green('Tokens compiled.'), chalk.green.bold('SUCCESS'));
    return true;
  } catch (err) {
    console.log(chalk.red.bold(err));
    if (options.watch) {
      return true; // If --watch was passed, return true to keep the watcher running
    } else {
      process.exit(1);
    }
  }
}
